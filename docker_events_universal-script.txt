# stop old services
sudo systemctl stop docker_events_gpu.service
sudo systemctl stop docker_events_cpu.service
sudo systemctl stop docker_events.service

# disable so it doesnt run on reboot
sudo systemctl disable docker_events_gpu.service
sudo systemctl disable docker_events_cpu.service
sudo systemctl disable docker_events.service

#========================================================================================================
#========================================================================================================

# -- write docker_events_universal script --

sudo tee /usr/local/bin/docker_events_universal.sh > /dev/null <<'EOF'
#!/bin/bash

BASE_DIR="/home/user/miners"

source $BASE_DIR/miner_paths.env

get_rig_conf() {
    local default_oc_file="/home/user/rig-cpu.conf"

    # Safe checks under set -u
    if [[ -n "${oc_file:-}" ]]; then
        cfg_file="$oc_file"
    elif [[ -n "${OC_FILE:-}" ]]; then
        cfg_file="$OC_FILE"
    else
        cfg_file="$default_oc_file"
    fi

    local key="$1"     # e.g., TARGET_IMAGE
    local gpu_id="$2"  # usually "0" in your examples

    # If file missing, return empty
    [[ ! -f "$cfg_file" ]] && echo "" && return

    local selected_value=""
    local file_key file_gpu rest_of_line value

    # Read key, gpu, and rest of line into rest_of_line
    while read -r file_key file_gpu rest_of_line; do

        # Skip empty or comment lines
        [[ -z "$file_key" || "$file_key" =~ ^# ]] && continue

        # Skip non-matching keys
        [[ "$file_key" != "$key" ]] && continue

        # Everything after 2nd column is the value
        value="$rest_of_line"

        # Remove surrounding quotes
        value="${value#\"}"
        value="${value%\"}"

        # GPU-specific match overrides ALL
        if [[ "$file_gpu" == "$gpu_id" ]]; then
            selected_value="$value"
            break
        fi

        # ALL fallback
        if [[ "$file_gpu" == "ALL" ]]; then
            selected_value="$value"
        fi

    done < "$cfg_file"

    echo "$selected_value"
}

###############################################
#  CONFIG
###############################################
# ---------------------------------------------------
# get_miner_bin <miner_name>
# Returns the correct binary path using existing *_BIN vars
# ---------------------------------------------------
get_miner_bin() {
    local name="$1"

    local custom=$(get_rig_conf "CUSTOM_MINER" "0")
    if [[ -n "$custom" ]]; then
        echo "$custom"
        return
    fi

    case "$name" in
        bzminer)      echo "$BZMINER_BIN" ;;
        wildrig)      echo "$WILDRIG_BIN" ;;
        xmrig)        echo "$XMRIG_BIN" ;;
        srbminer)     echo "$SRBMINER_BIN" ;;
        rigel)        echo "$RIGEL_BIN" ;;
        lolminer)     echo "$LOLMINER_BIN" ;;
        onezerominer) echo "$ONEZEROMINER_BIN" ;;
        gminer)       echo "$GMINER_BIN" ;;
        *)
            echo "$(date): Unknown miner '$name' — defaulting to bzminer" >&2
            echo "$BZMINER_BIN"
            ;;
    esac
}

get_start_cmd() {
    local name="$1"
    local cmd=""

    # ---------------------------------------------------------
    # CUSTOM MINER OVERRIDE
    # If CUSTOM_MINER is set in rig.conf:
    #   CUSTOM_MINER ALL "/path/to/customminer"
    #
    # Then build the command as:
    #   /path/to/customminer $ARGS
    #
    # No templates, no auto-flags — full manual control.
    # ---------------------------------------------------------
    local custom=$(get_rig_conf "CUSTOM_MINER" "0")
    if [[ -n "$custom" ]]; then
        cmd="$custom $ARGS"
        echo "$cmd"
        return
    fi

    # ---------------------------------------------------------
    # NORMAL BUILT-IN MINER COMMAND TEMPLATES
    # ---------------------------------------------------------
    case "$name" in

        bzminer)
            cmd="$MINER_BIN -a $ALGO -w $WALLET -p $POOL $ARGS"
            ;;

        wildrig)
            cmd="$MINER_BIN --algo $ALGO --user $WALLET --url $POOL --pass $PASS $ARGS"
            ;;

        xmrig)
            cmd="$MINER_BIN -a $ALGO -u $WALLET -o $POOL -p $PASS $ARGS"
            ;;

        srbminer)
            cmd="$MINER_BIN --algorithm $ALGO --pool $POOL --wallet $WALLET $ARGS"
            ;;

        rigel)
            cmd="$MINER_BIN --algo $ALGO --url $POOL --user $WALLET $ARGS"
            ;;

        lolminer)
            cmd="$MINER_BIN --algo $ALGO --pool $POOL --user $WALLET $ARGS"
            ;;

        onezerominer)
            cmd="$MINER_BIN --algo $ALGO --server $POOL --user $WALLET $ARGS"
            ;;

        gminer)
            cmd="$MINER_BIN --algo $ALGO --server $POOL --user $WALLET $ARGS"
            ;;

        *)
            echo "$(date): Unknown miner '$name', defaulting to bzminer" >&2
            cmd="$BZMINER_BIN -a $ALGO -w $WALLET -p $POOL $ARGS"
            ;;
    esac

    echo "$cmd"
}


# Worker name from hostname, normalized
WORKER_NAME="$(cat /etc/hostname)"
WORKER_NAME="${WORKER_NAME//x/X}"
WORKER_NAME="${WORKER_NAME//t/T}"

TARGET_IMAGE=$(get_rig_conf "TARGET_IMAGE" "0")
TARGET_NAME=$(get_rig_conf "TARGET_NAME" "0")

RESET_OC=$(get_rig_conf "RESET_OC" "0")

MINER_NAME=$(get_rig_conf "MINER" "0")

if [[ -z "$MINER_NAME" ]]; then
    echo "$(date): MINER not set in rig.conf, defaulting to bzminer"
    MINER_NAME="bzminer"
fi

MINER_BIN=$(get_miner_bin "$MINER_NAME")

echo "[miner] $MINER_BIN"

ALGO=$(get_rig_conf "ALGO" "0")
ARGS=$(get_rig_conf "ARGS" "0")

TOTAL_THREADS=$(nproc)
CPU_THREADS=$((TOTAL_THREADS - 1))

if [[ "$MINER_NAME" == "xmrig" ]]; then

    if [[ "$ALGO" == "rx/0" ]]; then

        RX_THREADS=-1

        if [[ "$TOTAL_THREADS" -eq 32 ]]; then

            RX_THREADS=31
            RX_CORES=(0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)

        elif [[ "$TOTAL_THREADS" -eq 24 ]]; then

            RX_THREADS=23
            RX_CORES=(0 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23)

        fi

        # ===========================
        # Build affinity mask OR fallback
        # ===========================
        if [[ "$RX_THREADS" -eq -1 ]]; then

            ARGS="${ARGS//%CPU_THREADS%/$CPU_THREADS}"

        else
            BITMASK=0
            for core in "${RX_CORES[@]}"; do
                (( BITMASK |= (1 << core) ))
            done

            RX_MASK=$(printf "0x%X" "$BITMASK")
            AUTOFILL_CPU="$RX_THREADS --cpu-affinity=$RX_MASK"

            ARGS="${ARGS//%CPU_THREADS%/$AUTOFILL_CPU}"
        fi
    else
        # Non-rx/0 xmrig
        ARGS="${ARGS//%CPU_THREADS%/$CPU_THREADS}"
    fi
else
    # Not xmrig
    ARGS="${ARGS//%CPU_THREADS%/$CPU_THREADS}"
fi


if [[ "$ALGO" == "warthog" ]]; then
    echo "Using warthog settings"
    # Compute Warthog target
    if [ "$TOTAL_THREADS" -eq 32 ]; then
        WARTHOG_TARGET=47000000
    elif [ "$TOTAL_THREADS" -eq 24 ]; then
        WARTHOG_TARGET=37000000
    else
        WARTHOG_TARGET=30000000
    fi
	
	ARGS="${ARGS//%WARTHOG_TARGET%/$WARTHOG_TARGET}"
fi

###############################################
#  MINER SETTINGS
###############################################

POOL=$(get_rig_conf "POOL" "0")
WALLET=$(get_rig_conf "WALLET" "0")
PASS=$(get_rig_conf "PASS" "0")

# Replace %WORKER_NAME% placeholder in ARGS, WALLET, PASS, POOL
ARGS="${ARGS//%WORKER_NAME%/$WORKER_NAME}"
WALLET="${WALLET//%WORKER_NAME%/$WORKER_NAME}"
PASS="${PASS//%WORKER_NAME%/$WORKER_NAME}"
POOL="${POOL//%WORKER_NAME%/$WORKER_NAME}"

START_CMD=$(get_start_cmd "$MINER_NAME")

# Load from rig.conf
SCREEN_NAME=$(get_rig_conf "SCREEN_NAME" "0")

# If SCREEN_NAME is empty (""), ignore and use miner name
if [[ -z "$SCREEN_NAME" ]]; then
    SCREEN_NAME="$MINER_NAME"
fi

###############################################
#  FUNCTIONS
###############################################

# Function to start miner
start_miner() {
    if ! screen -list | grep -q "$SCREEN_NAME"; then
	    echo "$(date): Starting $SCREEN_NAME..."
		echo "$SCREEN_NAME" $START_CMD
		screen -dmS "$SCREEN_NAME" bash -c "$START_CMD"
        echo "Miner started in screen session: $SCREEN_NAME"
        echo "ARGS/OCS: $ARGS"
        echo "To view miner output: sudo screen -r $SCREEN_NAME"
    else
        echo "$(date): Miner already running in screen session: $SCREEN_NAME"
    fi
}
# Function to stop miner
stop_miner() {
    if screen -list | grep -q "$SCREEN_NAME"; then
        echo "$(date): Stopping $SCREEN_NAME miner..."
        
        # Kill the screen session cleanly
        screen -S "$SCREEN_NAME" -X quit

        echo "Sleeping 5 seconds to allow miner to exit..."
        sleep 5

        if [[ "${RESET_OC,,}" == "true" ]]; then
            echo "Resetting GPU clocks and power limits..."
            /usr/local/bin/gpu_reset_poststop.sh
        fi
    else
        echo "$(date): No $SCREEN_NAME miner screen session found — nothing to stop."
    fi

    echo "Final sleep 5 seconds..."
    sleep 5
}

check_target_container() {
    # Get all containers based on image
    candidates=$(docker ps -a \
        --filter "ancestor=${TARGET_IMAGE}" \
        --format "{{.ID}} {{.Names}}")

    match_id=""

    while read -r cid cname; do
        # Exact match
        if [[ "$cname" == "$TARGET_NAME" ]]; then
            match_id="$cid"
            break
        fi

        # Prefix match: name begins with TARGET_NAME
        if [[ "$cname" == ${TARGET_NAME}* ]]; then
            suffix="${cname#${TARGET_NAME}}"

            # Suffix must be 1+ digits ONLY
            if [[ "$suffix" =~ ^[0-9]+$ ]]; then
                match_id="$cid"
                break
            fi
        fi
    done <<< "$candidates"

    # No matching container found
    if [ -z "$match_id" ]; then
        echo "no matching container treat as stopped"
        return 1
    fi

    # Check container status
    status=$(docker inspect -f '{{.State.Status}}' "$match_id" 2>/dev/null)

    if [ "$status" = "running" ]; then
        return 0
    else
        echo "status=$status treat as stopped"
        return 1
    fi
}

###############################################
#  INITIAL CHECK
###############################################

if check_target_container; then
    echo "$(date): Target container (${TARGET_IMAGE} name ${TARGET_NAME}) detected at startup"
    start_miner
else
    echo "$(date): Target container (${TARGET_IMAGE} name ${TARGET_NAME}) not found at startup"
    stop_miner
fi

###############################################
#  DOCKER EVENT LOOP
###############################################

echo "$(date): Starting Docker event monitor..."

docker events --format "{{.Type}} {{.Action}} {{.Actor.Attributes.name}} {{.Actor.Attributes.image}}" | \
while read type action name image; do

    if [ "$type" != "container" ]; then
        echo "$(date): non-container event: Type: $type, Action: $action, Name: $name"
        continue
    fi

    echo "$(date): Container event detected - Action: $action, Name: $name, Image: $image"

    #########################################################
    # NAME MATCHING — Exact, or Starts-With + DIGIT SUFFIX
    #########################################################
    name_match=0

    # Exact match
    if [[ "$name" == "$TARGET_NAME" ]]; then
        name_match=1

    # Starts-with, check digit suffix
    elif [[ "$name" == ${TARGET_NAME}* ]]; then
        suffix="${name#${TARGET_NAME}}"
        if [[ "$suffix" =~ ^[0-9]+$ ]]; then
            name_match=1
        fi
    fi

    #########################################################
    # Process only if image AND name match
    #########################################################
    if [[ "$image" == "$TARGET_IMAGE" && "$name_match" -eq 1 ]]; then

        case "$action" in

            start|create|unpause)
                echo "$(date): START event detected → start_miner"
                start_miner
                ;;

            pause|kill|destroy|stop|die)
                echo "$(date): STOP event detected → checking container"
                if ! check_target_container; then
                    stop_miner
                fi
                ;;

            *)
                # Ignore irrelevant Docker events
                ;;
        esac
    fi
done
EOF

# service makes executable on start

#========================================================================================================
#========================================================================================================

# let daemon know about changes
sudo systemctl daemon-reload

# enable so it starts on boot, start service
sudo systemctl enable docker_events_gpu.service
sudo systemctl start docker_events_gpu.service

# follow service logs
sudo journalctl -u docker_events_gpu.service -f


sudo systemctl enable docker_events_cpu.service
sudo systemctl start docker_events_cpu.service

sudo journalctl -u docker_events_cpu.service -f

# check service status
sudo systemctl status docker_events_gpu.service
sudo systemctl status docker_events_cpu.service